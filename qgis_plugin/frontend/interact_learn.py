# -*- coding: utf-8 -*-
"""
/***************************************************************************
 InteractLearn
                                 A QGIS plugin
 Framework to test the algos designed during my PhD
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-16
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Gaston Lenczner
        email                : gaston.lenczner@delair.aero
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from os import path
from functools import partial

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QShortcut

from qgis.core import (
    Qgis,
    QgsApplication,
    QgsField,
    QgsFields,
    QgsProject,
    QgsRasterLayer,
    QgsTask,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsWkbTypes,
)
from qgis.PyQt.QtCore import QVariant

from .set_points import SetPoints
from .core import QgsCorePlugin
from .dialogs import InteractLearnDialog
from .utils import (
    WarnQgs,
    client_to_server,
    file_in_layers,
    get_layers,
    raster_to_file,
    set_renderer_raster,
    set_renderer_vector,
)


class InteractLearn(QgsCorePlugin):
    def __init__(self, iface):
        super().__init__(iface)
        # Will contain the different files used to send to the daemon and the crop coordinates
        self.files = {"crop_coords": None, "polygonize": None, "annot_layer": None}
        self.task = None
        self.dlg = None
        self.n_classes = None
        self.map_tool = None
        self.extent = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = "frontend/icons/wow.png"
        icon_nn_path = "frontend/icons/nn_.png"
        icon_click_path = "frontend/icons/point.png"
        self.add_action(
            icon_path,
            text=self.tr("Set neural network (F6)"),
            callback=self.gui_dialog,
            parent=self.iface.mainWindow(),
            shortcut="F6",
        )
        self.add_action(
            icon_nn_path,
            text=self.tr("Inference (F4)"),
            callback=self.infer_only,
            parent=self.iface.mainWindow(),
            shortcut="F4",
        )
        self.add_action(
            icon_click_path,
            text=self.tr("Clicky click (F3)"),
            callback=self.clicky,
            parent=self.iface.mainWindow(),
        )

        short = QShortcut("F3", self.iface.mainWindow())
        short.setContext(Qt.ApplicationShortcut)
        short.activated.connect(partial(self._set_class_annot))

    def gui_dialog(self):
        """Interact with the user with the GUI"""

        self.dlg = InteractLearnDialog(self.iface)
        if self.first_start:
            if not QgsProject.instance().layerTreeRoot().findLayers():
                WarnQgs(
                    "Please load at least one layer to launch this segmentation plugin.",
                    self.iface,
                )(Qgis.Critical)
                return

            layers, layers_names = get_layers()
            idx = layers.index(self.iface.activeLayer())
            self.dlg.sub_dlg.listWidget.item(idx).setSelected(True)
            self.dlg.textEdit.setText(str(layers_names[idx]) + "\n")
        else:
            self.dlg.init_from_previous_state(self.files)

        self.dlg.show()
        self.dlg.finished.connect(self.dialog_finished)

    def dialog_finished(self, status):
        """Launched once the GUI is closed.
         - Load all the data from pyqt objects
         -  check their integrity
         - Ends calling the daemon with `self.qgs_task`.
        """
        if self.dlg.map_tool:
            self.iface.mapCanvas().unsetMapTool(self.dlg.map_tool)
        if status:
            self.first_start = False
            self._load_data()
            msg = self._check_data()
            if msg:
                WarnQgs(msg, self.iface)(Qgis.Critical)
                return
            self.qgs_task()

    def infer_only(self):
        """Calls `self.qgs_task` with the same parameters than `self.dialog_finished`."""
        if self.dlg is None:
            WarnQgs(
                "Set parameters for inference first with the `IL` button", self.iface
            )(Qgis.Warning)
        else:
            self.files["reset"] = False
            if self.dlg.checkBox_crop.isChecked():
                self.files["crop_coords"] = self.dlg.map_tool.get_data()
            else:
                self.files["crop_coords"] = False
            self.qgs_task()

    def qgs_task(self):
        """Send data to daemon and activate it."""
        load_qgs = bool(file_in_layers(self.files["output_file"]))
        self._set_annot_lyr(load=load_qgs)
        # send data to daemon
        WarnQgs("Neural network magic in the background", self.iface)(level=Qgis.Info)
        task = QgsTask.fromFunction(
            "Neural network",
            client_to_server,
            on_finished=self._completed,
            data=self.files,
        )
        QgsApplication.taskManager().addTask(task)
        self.task = (
            task
        )  # necessary to keep a pointer on task to activate on_finished function.

    def clicky(self):
        """To make the clicks."""
        if self.first_start:
            WarnQgs("Make at least one inference before annotating.", self.iface)(
                level=Qgis.Warning
            )
            return
        self._set_annot_lyr()
        layer = self.iface.activeLayer()

        ### Annotation dialog
        self.map_tool = SetPoints(self.iface, layer)
        result = self.map_tool.set_class()
        if result:
            left_test = (
                self.map_tool.id_class_left < 0
                or self.map_tool.id_class_left >= self.n_classes
            )
            right_test = (
                self.map_tool.id_class_right < 0
                or self.map_tool.id_class_right >= self.n_classes
            )
            if left_test or right_test:
                WarnQgs(
                    f"Set valid class ids (between 0 and {self.n_classes - 1}).",
                    self.iface,
                )(Qgis.Critical)
                return
            self._set_class_annot()

    def _load_data(self):
        """Load data into `self.files` from pyqt objects"""
        self.files["input_files"] = raster_to_file(
            self.dlg.sub_dlg.listWidget.selectedItems()
        )
        self.files["output_file"] = self.dlg.line_output.text()
        self.files["neural_network"] = self.dlg.line_nn.text()
        if self.dlg.checkBox_geojson.isChecked():
            self.files["polygonize"] = (
                self.dlg.line_output.text().split(".")[0] + ".geojson"
            )
        else:
            self.files["polygonize"] = False
            # retrieve coordinates of the crop if asked
        if self.dlg.checkBox_crop.isChecked():
            self.files["crop_coords"] = self.dlg.map_tool.get_data()
        else:
            self.files["crop_coords"] = False
        self.files["interactive"] = self.dlg.checkBox_interactive.isChecked()
        self.files["interact_use_annots"] = self.dlg.checkBox_use_annot.isChecked()
        self.files["task"] = self.dlg.taskbox.currentText()
        self.files["ssh"] = self.dlg.checkBox_ssh.isChecked()
        self.files["dist_map"] = self.dlg.checkBox_dist_map.isChecked()
        self.files["reset"] = self.dlg.radioButton.isChecked()
        if self.files["reset"]:
            self._set_annot_lyr(overwrite=True)  # reset annotation layer

        layers, layers_names = get_layers()
        idx_input_lyr = layers_names.index(self.dlg.sub_dlg.listWidget.selectedItems()[0].text())
        self.extent = layers[idx_input_lyr].extent()  # extent of the input

    def _check_data(self):
        """Check if files are consistent"""
        msg = ""
        for lyr in [file_in_layers(i) for i in self.files["input_files"]]:
            if not isinstance(lyr, QgsRasterLayer):
                msg += f"Expect only raster layers as inputs.\n"
                break
        if not path.isfile(self.files["neural_network"]):
            msg += "The provided filename for the neural network does not exist.\n"
        if not path.exists(path.dirname(self.files["output_file"])):
            msg += "The provided directory for the output does not exist.\n"
        if path.isdir(self.files["output_file"]):
            msg += "Provide a filename for the output instead of a directory.\n"
        if "." in self.files["output_file"]:
            if not (
                self.files["output_file"].endswith(".tiff")
                or self.files["output_file"].endswith(".tif")
            ):
                msg += "Only Geotiff format accepted for the output (.tif)\n"
        else:
            self.files["output_file"] += ".tif"
        if self.files["output_file"] in self.files["input_files"]:
            msg += "The output file is the same than an input file."
        return msg

    def _set_annot_lyr(self, overwrite=False, load=True):
        """load annotation layer (create it if it doesn't exist).
            overwrite: bool  overwrite annotation file if set to True
            load: bool  load layer in qgis
            """
        name = self.files["output_file"].split(".")[0] + ".shp"
        if self.files["annot_layer"] != name:
            self.files["annot_layer"] = name

        if not path.isfile(name) or overwrite:
            fields = QgsFields()
            fields.append(QgsField("class", QVariant.Int))
            crs = file_in_layers(self.files["input_files"][0]).crs()
            QgsVectorFileWriter(
                name,
                "UTF-8",
                fields,
                QgsWkbTypes.Point,
                crs,
                driverName="ESRI Shapefile",
            )

        if load:
            lyr = file_in_layers(name)
            if lyr:
                self.iface.setActiveLayer(lyr)
            else:
                name_lyr = "_".join(
                    [
                        "annots",
                        path.splitext(path.basename(self.files["annot_layer"]))[0],
                    ]
                )
                lyr = QgsVectorLayer(name, name_lyr, "ogr")
                QgsProject.instance().addMapLayer(lyr)
            if self.n_classes is not None:
                set_renderer_vector(lyr, self.n_classes)

    def _set_class_annot(self):
        """set annotation tool"""
        if self.map_tool is None:
            WarnQgs("Set annotations classes before using this shortcut.", self.iface)(
                Qgis.Warning
            )
        else:
            self.iface.mapCanvas().setMapTool(self.map_tool)

    def _completed(self, exception, result=None):
        """Executed on_finished, i.e. when receiving an answer from the daemon."""
        if exception is not None:
            if isinstance(exception, ConnectionRefusedError):
                msg = "Daemon not running. If it's running using ssh, check the ssh information in connexion_setup.yml"
            else:
                msg = f"See server logs: {exception}"
            WarnQgs(msg, self.iface)(Qgis.Critical)
            return
        if isinstance(result, str):
            WarnQgs(result, self.iface)(level=Qgis.Warning)
        elif isinstance(result, int):
            # daemon returns the number of classes
            self.n_classes = result
            self.iface.mapCanvas().refreshAllLayers()
            f = (
                self.files["polygonize"]
                if self.files["polygonize"]
                else self.files["output_file"]
            )
            if not file_in_layers(f):
                if self.files["polygonize"]:
                    self.iface.addVectorLayer(self.files["polygonize"], "", "ogr")
                    active_layer = self.iface.activeLayer()
                    set_renderer_vector(active_layer, self.n_classes)
                else:
                    layer_name = path.basename(self.files["output_file"]).split(".")[0]
                    self.iface.addRasterLayer(self.files["output_file"], layer_name)
                    active_layer = self.iface.activeLayer()
                    active_layer.setExtent(self.extent)  # necessary if the output file has been deleted
                    set_renderer_raster(active_layer, self.n_classes)
            self._set_annot_lyr()
        else:
            WarnQgs("Wrong output type. Expect str or WarnQgs.", self.iface)(
                Qgis.Critical
            )
            return
